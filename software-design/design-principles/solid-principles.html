<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>SOLID Principles</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/darshandsoni/asciidoctor-skins/css/material-teal.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>SOLID Principles</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_references">References</a></li>
<li><a href="#_srp">SRP</a></li>
<li><a href="#_ocp">OCP</a>
<ul class="sectlevel2">
<li><a href="#_definition_of_the_openclosed_principle">Definition of the Open/Closed Principle</a></li>
<li><a href="#_key_points">Key Points</a></li>
</ul>
</li>
<li><a href="#_lsp">LSP</a></li>
<li><a href="#_isp">ISP</a>
<ul class="sectlevel2">
<li><a href="#_goal">Goal</a></li>
</ul>
</li>
<li><a href="#_dip">DIP</a>
<ul class="sectlevel2">
<li><a href="#_definition_of_the_dependency_inversion_principle">Definition of the Dependency Inversion Principle</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>SRP - Single Responsibility Principle</p>
</li>
<li>
<p>OCP - Open/Close Principle</p>
</li>
<li>
<p>LSP  - Liskov Substitution Principle</p>
</li>
<li>
<p>ISP   - Interface Segregation Principle</p>
</li>
<li>
<p>DIP  -  Dependency Inversion Principle</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references">References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://stackify.com/solid-design-principles/" class="bare">https://stackify.com/solid-design-principles/</a></p>
</li>
<li>
<p><a href="https://stackify.com/solid-design-open-closed-principle/" class="bare">https://stackify.com/solid-design-open-closed-principle/</a></p>
</li>
<li>
<p><a href="https://stackify.com/solid-design-liskov-substitution-principle/" class="bare">https://stackify.com/solid-design-liskov-substitution-principle/</a></p>
</li>
<li>
<p><a href="https://stackify.com/interface-segregation-principle/" class="bare">https://stackify.com/interface-segregation-principle/</a></p>
</li>
<li>
<p><a href="https://stackify.com/dependency-inversion-principle/" class="bare">https://stackify.com/dependency-inversion-principle/</a></p>
</li>
<li>
<p><a href="https://medium.com/mindorks/solid-principles-explained-with-examples-79d1ce114ace" class="bare">https://medium.com/mindorks/solid-principles-explained-with-examples-79d1ce114ace</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_srp">SRP</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_ocp">OCP</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_definition_of_the_openclosed_principle">Definition of the Open/Closed Principle</h3>
<div class="paragraph">
<p>Robert C. Martin considered this principle as the “the most important principle of object-oriented design”. But he wasn’t the first one who defined it. Bertrand Meyer wrote about it in 1988 in his book Object-Oriented Software Construction. He explained the Open/Closed Principle as:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Bertrand Meyer
</div>
</div>
<div class="paragraph">
<p>The general idea of this principle is great. It tells you to write your code so that you will be able to add new functionality without changing the existing code. That prevents situations in which a change to one of your classes also requires you to adapt all depending classes. Unfortunately, Bertrand Mayer proposes to use inheritance to achieve this goal:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>A class is closed, since it may be compiled, stored in a library, baselined, and used by client classes. But it is also open, since any new class may use it as parent, adding new features. When a descendant class is defined, there is no need to change the original or to disturb its clients.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Bertrand Mayer
</div>
</div>
<div class="paragraph">
<p>But as we’ve learned over the years and as other authors explained in great details, e.g., Robert C. Martin in his articles about the SOLID principles or Joshua Bloch in his book Effective Java, <mark>inheritance introduces tight coupling if the subclasses depend on implementation details of their parent class</mark>.
That’s why Robert C. Martin and others redefined the Open/Closed Principle to the Polymorphic Open/Closed Principle. It uses interfaces instead of superclasses to allow different implementations which you can easily substitute without changing the code that uses them. The interfaces are closed for modifications, and you can provide new implementations to extend the functionality of your software.
The main benefit of this approach is that an interface introduces an additional level of abstraction which enables loose coupling. The implementations of an interface are independent of each other and don’t need to share any code. If you consider it beneficial that two implementations of an interface share some code, you can either use inheritance or composition.</p>
</div>
</div>
<div class="sect2">
<h3 id="_key_points">Key Points</h3>
<div class="ulist">
<ul>
<li>
<p>Advocates interfaces over superclasses&#8201;&#8212;&#8201;<mark>inheritance introduces tight coupling if the subclasses depend on implementation details of their parent class</mark></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lsp">LSP</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The principle defines that objects of a superclass shall be replaceable with objects of its subclasses without breaking the application. That requires the objects of your subclasses to behave in the same way as the objects of your superclass. You can achieve that by following a few rules, which are pretty similar to the design by contract concept defined by Bertrand Meyer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_isp">ISP</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_goal">Goal</h3>
<div class="paragraph">
<p>Similar to the Single Responsibility Principle, the goal of the Interface Segregation Principle is to <mark>reduce the side effects and frequency of required changes</mark> by splitting the software into multiple, independent parts.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dip">DIP</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_definition_of_the_dependency_inversion_principle">Definition of the Dependency Inversion Principle</h3>
<div class="paragraph">
<p>The general idea of this principle is as simple as it is important: High-level modules, which provide complex logic, should be easily reusable and unaffected by changes in low-level modules, which provide utility features. To achieve that, you need to introduce an abstraction that decouples the high-level and low-level modules from each other.</p>
</div>
<div class="paragraph">
<p>Based on this idea, Robert C. Martin’s definition of the Dependency Inversion Principle consists of two parts:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>High-level modules should not depend on low-level modules. Both should depend on abstractions.</p>
</li>
<li>
<p>Abstractions should not depend on details. Details should depend on abstractions.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>An important detail of this definition is, that high-level <strong>and</strong> low-level modules depend on the abstraction. The design principle does not just change the direction of the dependency, as you might have expected when you read its name for the first time. It splits the dependency between the high-level and low-level modules by introducing an abstraction between them. So in the end, you get two dependencies:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the high-level module depends on the abstraction, and</p>
</li>
<li>
<p>the low-level depends on the same abstraction.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-06-22 13:10:08 UTC
</div>
</div>
</body>
</html>