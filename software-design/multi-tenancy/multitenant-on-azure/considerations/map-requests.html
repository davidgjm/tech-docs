<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>map requests</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/darshandsoni/asciidoctor-skins/css/material-teal.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>map requests</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_approaches_to_identify_tenants">Approaches to identify tenants</a>
<ul class="sectlevel2">
<li><a href="#_domain_names">Domain names</a></li>
<li><a href="#_http_request_properties">HTTP request properties</a></li>
<li><a href="#_token_claims">Token claims</a></li>
<li><a href="#_api_keys">API keys</a></li>
<li><a href="#_client_certificates">Client certificates</a></li>
</ul>
</li>
<li><a href="#_reverse_proxies">Reverse Proxies</a></li>
<li><a href="#_request_validation">Request validation</a></li>
<li><a href="#_performance">Performance</a></li>
<li><a href="#_session_affinity">Session affinity</a></li>
<li><a href="#_tenant_migration">Tenant migration</a></li>
<li><a href="#_next_steps">Next steps</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Whenever a request arrives into your application, you need to determine the tenant that the request is intended for. When you have tenant-specific infrastructure that may even be hosted in different geographic regions, you need to match the incoming request to a tenant. Then, you must forward the request to the physical infrastructure that hosts that tenant&#8217;s resources, as illustrated below:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/map-logical-physical.png" alt="map logical physical">
</div>
</div>
<div class="paragraph">
<p>On this page, we provide guidance for technical decision-makers about the approaches you can consider to map requests to the appropriate tenant, and the tradeoffs involved in the approaches.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This page mostly discusses HTTP-based applications, like websites and APIs. However, many of same underlying principles apply to multitenant applications that use other communication protocols.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_approaches_to_identify_tenants">Approaches to identify tenants</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are multiple ways you can identify the tenant for an incoming request.</p>
</div>
<div class="sect2">
<h3 id="_domain_names">Domain names</h3>
<div class="paragraph">
<p>If you use <a href="domain-names.html">tenant-specific domain or subdomain names</a>, it&#8217;s likely that requests can be easily mapped to tenants by using the <code>Host</code> header, or another HTTP header that includes the original hostname for each request.</p>
</div>
<div class="paragraph">
<p>However, consider the following questions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How will users know which domain name to use to access the service?</p>
</li>
<li>
<p>Do you have a central entry point, like a landing page or login page, that all the tenants use? If you do, how will users identify the tenant that they need to access?</p>
</li>
<li>
<p>What other information are you using to verify access to the tenant, such as authorization tokens? Do the authorization tokens include the tenant-specific domain names?</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_http_request_properties">HTTP request properties</h3>
<div class="paragraph">
<p>If you don&#8217;t use tenant-specific domain names, you might still be able to use aspects of the HTTP request to identify the tenant that a particular request is for. For example, consider an HTTP request that identifies the tenant name as tailwindtraders. This might be communicated using the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>The URL path structure</strong>, such as <code><a href="https://app.contoso.com/tailwindtraders/" class="bare">https://app.contoso.com/tailwindtraders/</a></code>.</p>
</li>
<li>
<p><strong>A query string in the URL</strong>, such as <code><a href="https://contoso.com/app?tenant=tailwindtraders" class="bare">https://contoso.com/app?tenant=tailwindtraders</a></code>.</p>
</li>
<li>
<p><strong>A custom HTTP request header</strong>, such as <code>X-Tenant-Id: tailwindtraders</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Custom HTTP request headers aren&#8217;t useful where HTTP GET requests are issued from a web browser, or where the requests are handled by some types of web proxy.You should only use custom HTTP headers for GET operations when you&#8217;re building an API, or if you control the client that issues the request and there&#8217;s no web proxy included in the request processing chain.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using this approach, you should consider the following questions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Will users know how to access the service?For example, if you use a query string to identify tenants, will a central landing page need to direct users to the correct tenant, by adding the query string?</p>
</li>
<li>
<p>Do you have a central entry point, like a landing page or login page, that all tenants use?If you do, how will users identify the tenant that they need to access?</p>
</li>
<li>
<p>Does your application provide APIs?For example, is your web application a single-page application (SPA) or a mobile application with an API backend?If it is, you might be able to use an <a href="https://docs.microsoft.com/en-us/azure/architecture/microservices/design/gateway">API gateway</a> or <a href="#_reverse_proxies">reverse proxy</a> to perform tenant mapping.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_token_claims">Token claims</h3>
<div class="paragraph">
<p>Many applications use claims-based authentication and authorization protocols, such as OAuth 2.0 or SAML. These protocols provide authorization tokens to the client. A token contains a set of <em>claims</em>, which are pieces of information about the client application or user. Claims can be used to communicate information like a user&#8217;s email address. Your system can then include the user&#8217;s email address, look up the user-to-tenant mapping, and then forward the request to the appropriate physical tenant infrastructure. Or, you might even include the tenant mapping in your identity system, and add a tenant ID claim to the token.</p>
</div>
<div class="paragraph">
<p>If you are using claims to map requests to tenants, you should consider the following questions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Will you use a claim to identify a tenant? Which claim will you use?</p>
</li>
<li>
<p>Can a user be a member of multiple tenants? If this is possible, then how will users select the tenants they&#8217;d like to work with?</p>
</li>
<li>
<p>Is there a central authentication and authorization system for all tenants? If not, how will you ensure that all token authorities issue consistent tokens and claims?</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_api_keys">API keys</h3>
<div class="paragraph">
<p>Many applications expose APIs. These might be for internal use within your organization, or for external use by partners or customers. A common method of authentication for APIs is to use an <em>API key</em>. API keys are provided with each request, and they can be used to look up the tenant.</p>
</div>
<div class="paragraph">
<p>API keys can be generated in several ways. A common approach is to generate a cryptographically random value and store it in a lookup table, alongside the tenant ID. When a request is received, your system finds the API key in the lookup table, and it then matches it to a tenant ID. Another approach is to create a meaningful string with a tenant ID included inside it, and then you would digitally sign the key, by using an approach like <a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a>. When you process each request, you verify the signature and then extract the tenant ID.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>API keys don&#8217;t provide a high level of security because they need to be manually created and managed, and because they don&#8217;t contain claims. A more modern and secure approach is to use a claims-based authorization mechanism with short-lived tokens, such as OAuth 2.0 or OpenID Connect.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider the following questions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How will you generate and issue API keys?</p>
</li>
<li>
<p>How will your API clients securely receive and store the API key?</p>
</li>
<li>
<p>Do you need your API keys to expire after a period of time? How will you rotate your clients' API keys, without causing downtime?</p>
</li>
<li>
<p>Does just relying on customer-rolled API keys provide an adequate level of security for your APIs?</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
API keys are not the same as passwords. API keys must be generated by the system, and they must be unique across all the tenants, so that each API key can be uniquely mapped to a single tenant. API gateways, such as <a href="https://docs.microsoft.com/en-us/azure/api-management/api-management-subscriptions">Azure API Management</a>, can generate and manage API keys, validate keys on incoming requests, and map keys to individual API subscribers.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_client_certificates">Client certificates</h3>
<div class="paragraph">
<p>Client certificate authentication, sometimes called mutual TLS (mTLS), is commonly used for service-to-service communication. Client certificates provide a secure way to authenticate clients. Similarly to tokens and claims, client certificates provide <em>attributes</em> that can be used to determine the tenant. For example, the subject of the certificate may contain the email address of the user, which can be used to look up the tenant.</p>
</div>
<div class="paragraph">
<p>When planning to use client certificates for tenant mapping consider the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How will you safely issue and renew the client certificates that are trusted by your service? Client certificates can be complex to work with, since they require special infrastructure to manage and issue certificates.</p>
</li>
<li>
<p>Will client certificates be used only for initial login requests, or attached to all requests to your service?</p>
</li>
<li>
<p>Will the process of issuing and managing certificates become unmanageable when you have a large number of clients?</p>
</li>
<li>
<p>How will you implement the mapping between the client certificate and the tenant?</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reverse_proxies">Reverse Proxies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A reverse proxy, also referred to as an application proxy, can be used to route HTTP requests. A reverse proxy accepts a request from an ingress endpoint, and it can forward the request to one of many backend endpoints. Reverse proxies are useful for multitenant applications since they can perform the mapping between some piece of request information, offloading the task from your application infrastructure.</p>
</div>
<div class="paragraph">
<p>Many reverse proxies can use the properties of a request to make a decision about tenant routing. They can inspect the destination domain name, URL path, query string, HTTP headers, and even claims within tokens.</p>
</div>
<div class="paragraph">
<p>The following common reverse proxies are used in Azure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Azure Front Door is a global load balancer and web application firewall. It uses the Microsoft global edge network to create fast, secure, and highly scalable web applications.</p>
</li>
<li>
<p>Azure Application Gateway is a managed web traffic load balancer that you deploy into the same physical region as your backend service.</p>
</li>
<li>
<p>Azure API Management is optimized for API traffic.</p>
</li>
<li>
<p>Commercial and open-source technologies (that you host yourself) include nginx, Traefik, and HAProxy.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_request_validation">Request validation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is important that your application validates that any requests that it receives are authorized for the tenant. For example, if your application uses a custom domain name to map requests to the tenant, then your application must still check that each request received by the application is authorized for that tenant. Even though the request includes a domain name or other tenant identifier, it doesn&#8217;t mean you should automatically grant access. When you use OAuth 2.0, you perform the validation by inspecting the <em>audience</em> and <em>scope</em> claims.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This is part of the <em>assume zero trust</em> security design principle in the <a href="https://docs.microsoft.com/en-us/azure/architecture/framework/security/security-principles">Microsoft Azure Well-Architected Framework</a>. When implementing request validation, you should consider the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How will you authorize all the requests to your application? You need to authorize requests, regardless of the approach you use to map them to physical infrastructure.</p>
</li>
<li>
<p>Use trusted and widely used authentication and authorization frameworks and middleware, instead of implementing all of the validation logic yourself. For example, don&#8217;t build token signature validation logic or client certificate cryptography libraries. Instead, use features of your application platform (or known trusted packages) that have been validated and tested.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_performance">Performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Tenant mapping logic likely runs on every request to your application. Consider how well the tenant mapping process will scale, as your solution grows. For example, if you query a database table as part of your tenant mapping, will the database support a large amount of load? If your tenant mapping requires decrypting a token, will the computation requirements become too high over time? If your traffic is fairly modest, then this isn&#8217;t likely to affect your overall performance. When you have a high-scale application, though, the overhead involved in this mapping can become significant.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_session_affinity">Session affinity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One approach to reducing the performance overhead of tenant mapping logic is to use session affinity. Rather than perform the mapping on every request, consider computing the information only on the first request for each session. Your application then provides a session cookie to the client that can then passed back to your service, with all subsequent client requests within that session.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Many networking and application services in Azure can issue session cookies and natively route requests by using session affinity.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider the following questions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Can you use session affinity to reduce the overhead of mapping requests to tenants?</p>
</li>
<li>
<p>What services do you use to route requests to the physical deployments for each tenant? Do these services support cookie-based session affinity?</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tenant_migration">Tenant migration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Tenants often need to be moved to new infrastructure as part of the <a href="tenant-lifecycle.html">tenant lifecycle</a>. When a tenant is moved to a new deployment, the HTTP endpoints they access might change. When this happens, consider that your tenant-mapping process needs to be updated. You may need to consider the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If your application uses domain names for mapping requests, then it might also require a DNS change at the time of the migration. The DNS change might take time to propagate to clients, depending on the time-to-live of the DNS entries in your DNS service.</p>
</li>
<li>
<p>If your migration changes the addresses of any endpoints during the migration process, then consider temporarily redirecting requests for the tenant to a maintenance page that automatically refreshes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_next_steps">Next steps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Learn about <a href="domain-names.html">considerations when you work with domain names in a multitenant application</a>.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-06-22 13:10:08 UTC
</div>
</div>
</body>
</html>