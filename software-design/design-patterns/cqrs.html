<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>CQRS pattern</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/darshandsoni/asciidoctor-skins/css/material-teal.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./rouge-github.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>CQRS pattern</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_context_and_problem">Context and problem</a></li>
<li><a href="#_solution">Solution</a></li>
<li><a href="#_implementation_issues_and_considerations">Implementation issues and considerations</a></li>
<li><a href="#_when_to_use_cqrs_pattern">When to use CQRS pattern</a></li>
<li><a href="#_event_sourcing_and_cqrs_pattern">Event Sourcing and CQRS pattern</a></li>
<li><a href="#_example_of_cqrs_pattern">Example of CQRS pattern</a></li>
<li><a href="#_next_steps">Next steps</a></li>
<li><a href="#_related_guidance">Related guidance</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="title">References</div>
<div class="ulist">
<ul>
<li>
<p>DDD</p>
</li>
<li>
<p><a href="../cloud/Azure/application-architecture/architecture-styles/event-driven.html">Event-driven architecture</a></p>
</li>
<li>
<p><a href="event-sourcing.html">Event Sourcing pattern</a></p>
</li>
<li>
<p><a href="https://martinfowler.com/articles/201701-event-driven.html">What do you mean by "Event-Driven"?</a></p>
</li>
<li>
<p><a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>CQRS stands for <strong><span class="underline">C</span>ommand and <span class="underline">Q</span>uery <span class="underline">R</span>esponsibility <span class="underline">S</span>egregation</strong>, a pattern that separates read and update operations for a data store. Implementing CQRS in your application can maximize its performance, scalability, and security. The flexibility created by migrating to CQRS allows a system to better evolve over time and prevents update commands from causing merge conflicts at the domain level.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_context_and_problem">Context and problem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In traditional architectures, the same data model is used to query and update a database. That&#8217;s simple and works well for basic CRUD operations. In more complex applications, however, this approach can become unwieldy. For example, on the read side, the application may perform many different queries, returning data transfer objects (DTOs) with different shapes. Object mapping can become complicated. On the write side, the model may implement complex validation and business logic. As a result, you can end up with an overly complex model that does too much.</p>
</div>
<div class="paragraph">
<p>Read and write workloads are often asymmetrical, with very different performance and scale requirements.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/command-and-query-responsibility-segregation-cqrs-tradition-crud.png" alt="command and query responsibility segregation cqrs tradition crud">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>There is often a mismatch between the read and write representations of the data, such as additional columns or properties that must be updated correctly even though they aren&#8217;t required as part of an operation.</p>
</li>
<li>
<p>Data contention can occur when operations are performed in parallel on the same set of data.</p>
</li>
<li>
<p>The traditional approach can have a negative effect on performance due to load on the data store and data access layer, and the complexity of queries required to retrieve information.</p>
</li>
<li>
<p>Managing security and permissions can become complex, because each entity is subject to both read and write operations, which might expose data in the wrong context.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_solution">Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>CQRS separates reads and writes into different models, using <strong>commands</strong> to update data, and <strong>queries</strong> to read data.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Commands should be task-based, rather than data centric. ("Book hotel room", not "set ReservationStatus to Reserved").</p>
</li>
<li>
<p>Commands may be placed on a queue for asynchronous processing, rather than being processed synchronously.</p>
</li>
<li>
<p>Queries never modify the database. A query returns a DTO that does not encapsulate any domain knowledge.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The models can then be isolated, as shown in the following diagram, although that&#8217;s not an absolute requirement.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/command-and-query-responsibility-segregation-cqrs-basic.png" alt="command and query responsibility segregation cqrs basic">
</div>
</div>
<div class="paragraph">
<p>Having separate query and update models simplifies the design and implementation. However, one disadvantage is that CQRS code can&#8217;t automatically be generated from a database schema using scaffolding mechanisms such as O/RM tools.</p>
</div>
<div class="paragraph">
<p>For greater isolation, you can physically separate the read data from the write data. In that case, the read database can use its own data schema that is optimized for queries. For example, it can store a <a href="materialized-view.html">materialized view</a> of the data, in order to avoid complex joins or complex O/RM mappings. It might even use a different type of data store. For example, the write database might be relational, while the read database is a document database.</p>
</div>
<div class="paragraph">
<p>If separate read and write databases are used, they must be kept in sync. Typically, this is accomplished by having the write model publish an event whenever it updates the database. For more information about using events, see <a href="../cloud/Azure/application-architecture/architecture-styles/event-driven.html">Event-driven architecture style</a>. Updating the database and publishing the event must occur in a single transaction.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/command-and-query-responsibility-segregation-cqrs-separate-stores.png" alt="command and query responsibility segregation cqrs separate stores">
</div>
</div>
<div class="paragraph">
<p>The read store can be a read-only replica of the write store, or the read and write stores can have a different structure altogether. Using multiple read-only replicas can increase query performance, especially in distributed scenarios where read-only replicas are located close to the application instances.</p>
</div>
<div class="paragraph">
<p>Separation of the read and write stores also allows each to be scaled appropriately to match the load. For example, read stores typically encounter a much higher load than write stores.</p>
</div>
<div class="paragraph">
<p>Some implementations of CQRS use the Event Sourcing pattern. With this pattern, application state is stored as a sequence of events. Each event represents a set of changes to the data. The current state is constructed by replaying the events. In a CQRS context, one benefit of Event Sourcing is that the same events can be used to notify other components â€” in particular, to notify the read model. The read model uses the events to create a snapshot of the current state, which is more efficient for queries. However, Event Sourcing adds complexity to the design.</p>
</div>
<div class="paragraph">
<p>Benefits of CQRS include:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Independent scaling.</dt>
<dd>
<p>CQRS allows the read and write workloads to scale independently, and may result in fewer lock contentions.</p>
</dd>
<dt class="hdlist1">Optimized data schemas.</dt>
<dd>
<p>The read side can use a schema that is optimized for queries, while the write side uses a schema that is optimized for updates.</p>
</dd>
<dt class="hdlist1">Security.</dt>
<dd>
<p>It&#8217;s easier to ensure that only the right domain entities are performing writes on the data.</p>
</dd>
<dt class="hdlist1">Separation of concerns.</dt>
<dd>
<p>Segregating the read and write sides can result in models that are more maintainable and flexible. Most of the complex business logic goes into the write model. The read model can be relatively simple.</p>
</dd>
<dt class="hdlist1">Simpler queries.</dt>
<dd>
<p>By storing a materialized view in the read database, the application can avoid complex joins when querying.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_issues_and_considerations">Implementation issues and considerations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some challenges of implementing this pattern include:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Complexity.</dt>
<dd>
<p>The basic idea of CQRS is simple. But it can lead to a more complex application design, especially if they include the Event Sourcing pattern.</p>
</dd>
<dt class="hdlist1">Messaging.</dt>
<dd>
<p>Although CQRS does not require messaging, it&#8217;s common to use messaging to process commands and publish update events. In that case, the application must handle message failures or duplicate messages. See the guidance on Priority Queues for dealing with commands having different priorities.</p>
</dd>
<dt class="hdlist1">Eventual consistency.</dt>
<dd>
<p>If you separate the read and write databases, the read data may be stale. The read model store must be updated to reflect changes to the write model store, and it can be difficult to detect when a user has issued a request based on stale read data.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_when_to_use_cqrs_pattern">When to use CQRS pattern</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Consider CQRS for the following scenarios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Collaborative domains where many users access the same data in parallel. CQRS allows you to define commands with enough granularity to minimize merge conflicts at the domain level, and conflicts that do arise can be merged by the command.</p>
</li>
<li>
<p>Task-based user interfaces where users are guided through a complex process as a series of steps or with complex domain models. The write model has a full command-processing stack with business logic, input validation, and business validation. The write model may treat a set of associated objects as a single unit for data changes (an aggregate, in DDD terminology) and ensure that these objects are always in a consistent state. The read model has no business logic or validation stack, and just returns a DTO for use in a view model. The read model is eventually consistent with the write model.</p>
</li>
<li>
<p>Scenarios where performance of data reads must be fine-tuned separately from performance of data writes, especially when the number of reads is much greater than the number of writes. In this scenario, you can scale out the read model, but run the write model on just a few instances. A small number of write model instances also helps to minimize the occurrence of merge conflicts.</p>
</li>
<li>
<p>Scenarios where one team of developers can focus on the complex domain model that is part of the write model, and another team can focus on the read model and the user interfaces.</p>
</li>
<li>
<p>Scenarios where the system is expected to evolve over time and might contain multiple versions of the model, or where business rules change regularly.</p>
</li>
<li>
<p>Integration with other systems, especially in combination with event sourcing, where the temporal failure of one subsystem shouldn&#8217;t affect the availability of the others.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This pattern isn&#8217;t recommended when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The domain or the business rules are simple.</p>
</li>
<li>
<p>A simple CRUD-style user interface and data access operations are sufficient.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider applying CQRS to limited sections of your system where it will be most valuable.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_event_sourcing_and_cqrs_pattern">Event Sourcing and CQRS pattern</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The CQRS pattern is often used along with the Event Sourcing pattern. CQRS-based systems use separate read and write data models, each tailored to relevant tasks and often located in physically separate stores. When used with the <a href="event-sourcing.html">Event Sourcing pattern</a>, the store of events is the write model, and is the official source of information. The read model of a CQRS-based system provides materialized views of the data, typically as highly denormalized views. These views are tailored to the interfaces and display requirements of the application, which helps to maximize both display and query performance.</p>
</div>
<div class="paragraph">
<p>Using the stream of events as the write store, rather than the actual data at a point in time, avoids update conflicts on a single aggregate and maximizes performance and scalability. The events can be used to asynchronously generate materialized views of the data that are used to populate the read store.</p>
</div>
<div class="paragraph">
<p>Because the event store is the official source of information, it is possible to delete the materialized views and replay all past events to create a new representation of the current state when the system evolves, or when the read model must change. The materialized views are in effect a durable read-only cache of the data.</p>
</div>
<div class="paragraph">
<p>When using CQRS combined with the Event Sourcing pattern, consider the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>As with any system where the write and read stores are separate, systems based on this pattern are only eventually consistent. There will be some delay between the event being generated and the data store being updated.</p>
</li>
<li>
<p>The pattern adds complexity because code must be created to initiate and handle events, and assemble or update the appropriate views or objects required by queries or a read model. The complexity of the CQRS pattern when used with the Event Sourcing pattern can make a successful implementation more difficult, and requires a different approach to designing systems. However, event sourcing can make it easier to model the domain, and makes it easier to rebuild views or create new ones because the intent of the changes in the data is preserved.</p>
</li>
<li>
<p>Generating materialized views for use in the read model or projections of the data by replaying and handling the events for specific entities or collections of entities can require significant processing time and resource usage. This is especially true if it requires summation or analysis of values over long periods, because all the associated events might need to be examined. Resolve this by implementing snapshots of the data at scheduled intervals, such as a total count of the number of a specific action that has occurred, or the current state of an entity.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example_of_cqrs_pattern">Example of CQRS pattern</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following code shows some extracts from an example of a CQRS implementation that uses different definitions for the read and the write models. The model interfaces don&#8217;t dictate any features of the underlying data stores, and they can evolve and be fine-tuned independently because these interfaces are separated.</p>
</div>
<div class="paragraph">
<p>The following code shows the read model definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="csharp"><span class="c1">// Query interface</span>
<span class="k">namespace</span> <span class="nn">ReadModel</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">interface</span> <span class="nc">ProductsDao</span>
  <span class="p">{</span>
    <span class="n">ProductDisplay</span> <span class="nf">FindById</span><span class="p">(</span><span class="kt">int</span> <span class="n">productId</span><span class="p">);</span>
    <span class="n">ICollection</span><span class="p">&lt;</span><span class="n">ProductDisplay</span><span class="p">&gt;</span> <span class="nf">FindByName</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">ICollection</span><span class="p">&lt;</span><span class="n">ProductInventory</span><span class="p">&gt;</span> <span class="nf">FindOutOfStockProducts</span><span class="p">();</span>
    <span class="n">ICollection</span><span class="p">&lt;</span><span class="n">ProductDisplay</span><span class="p">&gt;</span> <span class="nf">FindRelatedProducts</span><span class="p">(</span><span class="kt">int</span> <span class="n">productId</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">class</span> <span class="nc">ProductDisplay</span>
  <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Description</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">decimal</span> <span class="n">UnitPrice</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsOutOfStock</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">UserRating</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">class</span> <span class="nc">ProductInventory</span>
  <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">CurrentStock</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The system allows users to rate products. The application code does this using the <code>RateProduct</code> command shown in the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="csharp"><span class="k">public</span> <span class="k">interface</span> <span class="nc">ICommand</span>
<span class="p">{</span>
  <span class="n">Guid</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">RateProduct</span> <span class="p">:</span> <span class="n">ICommand</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="nf">RateProduct</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">Id</span> <span class="p">=</span> <span class="n">Guid</span><span class="p">.</span><span class="nf">NewGuid</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">public</span> <span class="n">Guid</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">ProductId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">Rating</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">public</span> <span class="kt">int</span> <span class="n">UserId</span> <span class="p">{</span><span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The system uses the <code>ProductsCommandHandler</code> class to handle commands sent by the application. Clients typically send commands to the domain through a messaging system such as a queue. The command handler accepts these commands and invokes methods of the domain interface. The granularity of each command is designed to reduce the chance of conflicting requests. The following code shows an outline of the <code>ProductsCommandHandler</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">ProductsCommandHandler</span> <span class="p">:</span>
    <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">AddNewProduct</span><span class="p">&gt;,</span>
    <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">RateProduct</span><span class="p">&gt;,</span>
    <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">AddToInventory</span><span class="p">&gt;,</span>
    <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">ConfirmItemShipped</span><span class="p">&gt;,</span>
    <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">UpdateStockFromInventoryRecount</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IRepository</span><span class="p">&lt;</span><span class="n">Product</span><span class="p">&gt;</span> <span class="n">repository</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">ProductsCommandHandler</span> <span class="p">(</span><span class="n">IRepository</span><span class="p">&lt;</span><span class="n">Product</span><span class="p">&gt;</span> <span class="n">repository</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">repository</span> <span class="p">=</span> <span class="n">repository</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nf">Handle</span> <span class="p">(</span><span class="n">AddNewProduct</span> <span class="n">command</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nf">Handle</span> <span class="p">(</span><span class="n">RateProduct</span> <span class="n">command</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">product</span> <span class="p">=</span> <span class="n">repository</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="n">command</span><span class="p">.</span><span class="n">ProductId</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">product</span><span class="p">.</span><span class="nf">RateProduct</span><span class="p">(</span><span class="n">command</span><span class="p">.</span><span class="n">UserId</span><span class="p">,</span> <span class="n">command</span><span class="p">.</span><span class="n">Rating</span><span class="p">);</span>
      <span class="n">repository</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="n">product</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nf">Handle</span> <span class="p">(</span><span class="n">AddToInventory</span> <span class="n">command</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nf">Handle</span> <span class="p">(</span><span class="n">ConfirmItemsShipped</span> <span class="n">command</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nf">Handle</span> <span class="p">(</span><span class="n">UpdateStockFromInventoryRecount</span> <span class="n">command</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_next_steps">Next steps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following patterns and guidance are useful when implementing this pattern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589800(v=pandp.10)">Data Consistency Primer</a>. Explains the issues that are typically encountered due to eventual consistency between the read and write data stores when using the CQRS pattern, and how these issues can be resolved.</p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/data-partitioning">Horizontal, vertical, and functional data partitioning</a>. Describes best practices for dividing data into partitions that can be managed and accessed separately to improve scalability, reduce contention, and optimize performance.</p>
</li>
<li>
<p>The patterns &amp; practices guide <a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj554200(v=pandp.10)">CQRS Journey</a>. In particular, <a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591573(v=pandp.10)">Introducing the Command Query Responsibility Segregation pattern</a> explores the pattern and when it&#8217;s useful, and <a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591568(v=pandp.10)">Epilogue: Lessons Learned</a> helps you understand some of the issues that come up when using this pattern.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Martin Fowler&#8217;s blog posts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://martinfowler.com/articles/201701-event-driven.html">What do you mean by "Event-Driven"?</a></p>
</li>
<li>
<p><a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_related_guidance">Related guidance</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="event-sourcing.html">Event Sourcing pattern</a>. Describes in more detail how Event Sourcing can be used with the CQRS pattern to simplify tasks in complex domains while improving performance, scalability, and responsiveness. As well as how to provide consistency for transactional data while maintaining full audit trails and history that can enable compensating actions.</p>
</li>
<li>
<p><a href="materialized-view.html">Materialized View pattern</a>. The read model of a CQRS implementation can contain materialized views of the write model data, or the read model can be used to generate materialized views.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-06-22 13:10:08 UTC
</div>
</div>
</body>
</html>