<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>Geode pattern</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/darshandsoni/asciidoctor-skins/css/material-teal.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Geode pattern</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_context_and_problem">Context and problem</a></li>
<li><a href="#_solution">Solution</a></li>
<li><a href="#_issues_and_considerations">Issues and considerations</a></li>
<li><a href="#_when_to_use_this_pattern">When to use this pattern</a></li>
<li><a href="#_examples">Examples</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The Geode pattern involves deploying a collection of backend services into a set of geographical nodes, each of which can service any request for any client in any region. This pattern allows serving requests in an active-active style, improving latency and increasing availability by distributing request processing around the globe.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/geode.jpg" alt="geode">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_context_and_problem">Context and problem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many large-scale services have specific challenges around geo-availability and scale. Classic designs often <em>bring the data to the compute</em> by storing data in a remote SQL server that serves as the compute tier for that data, relying on scale-up for growth.</p>
</div>
<div class="paragraph">
<p>The classic approach may present a number of challenges:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Network latency issues for users coming from the other side of the globe to connect to the hosting endpoint</p>
</li>
<li>
<p>Traffic management for demand bursts that can overwhelm the services in a single region</p>
</li>
<li>
<p>Cost-prohibitive complexity of deploying copies of app infrastructure into multiple regions for a 24x7 service</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Modern cloud infrastructure has evolved to enable geographic load balancing of front-end services, while allowing for geographic replication of backend services. For availability and performance, getting data closer to the user is good. When data is geo-distributed across a far-flung user base, the geo-distributed datastores should also be colocated with the compute resources that process the data. The geode pattern <em>brings the compute to the data</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_solution">Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Deploy the service into a number of satellite deployments spread around the globe, each of which is called a geode. The geode pattern harnesses key features of Azure to route traffic via the shortest path to a nearby geode, which improves latency and performance. Each geode is behind a global load balancer, and uses a geo-replicated read-write service like Azure Cosmos DB to host the data plane, ensuring cross-geode data consistency. Data replication services ensure that data stores are identical across geodes, so <em>all</em> requests can be served from all geodes.</p>
</div>
<div class="paragraph">
<p>The key difference between a <a href="deployment-stamp.html">deployment stamp</a> and a geode is that geodes never exist in isolation. There should always be more than one geode in a production platform.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/geode-dist.png" alt="geode dist">
</div>
</div>
<div class="paragraph">
<p>Geodes have the following characteristics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consist of a collection of disparate types of resources, often defined in a template.</p>
</li>
<li>
<p>Have no dependencies outside of the geode footprint and are self-contained. No geode is dependent on another to operate, and if one dies, the others continue to operate.</p>
</li>
<li>
<p>Are loosely coupled via an edge network and replication backplane. For example, you can use Azure Traffic Manager or Azure Front Door for fronting the geodes, while Azure Cosmos DB can act as the replication backplane. Geodes are not the same as clusters because they share a replication backplane, so the platform takes care of quorum issues.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The geode pattern occurs in big data architectures that use commodity hardware to process data colocated on the same machine, and MapReduce to consolidate results across machines. Another usage is near-edge compute, which brings compute closer to the intelligent edge of the network to reduce response time.</p>
</div>
<div class="paragraph">
<p>Services can use this pattern over dozens or hundreds of geodes. Furthermore, the resiliency of the whole solution increases with each added geode, since any geodes can take over if a regional outage takes one or more geodes offline.</p>
</div>
<div class="paragraph">
<p>It&#8217;s also possible to augment local availability techniques, such as availability zones or paired regions, with the geode pattern for global availability. This increases complexity, but is useful if your architecture is underpinned by a storage engine such as blob storage that can only replicate to a paired region. You can deploy geodes into an intra-zone, zonal, or regional footprint, with a mind to regulatory or latency constraints on location.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_issues_and_considerations">Issues and considerations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the following techniques and technologies to implement this pattern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Modern DevOps practices and tools to produce and rapidly deploy identical geodes across a large number of regions or instances.</p>
</li>
<li>
<p>Autoscaling to scale out compute and database throughput instances within a geode. Each geode individually scales out, within the common backplane constraints.</p>
</li>
<li>
<p>A front-end service like Azure Front Door that does dynamic content acceleration, split TCP, and Anycast routing.</p>
</li>
<li>
<p>A replicating data store like Azure Cosmos DB to control data consistency.</p>
</li>
<li>
<p>Serverless technologies where possible, to reduce always-on deployment cost, especially when load is frequently rebalanced around the globe. This strategy allows for many geodes to be deployed with minimal additional investment. Serverless and consumption-based billing technologies reduce waste and cost from duplicate geo-distributed deployments.</p>
</li>
<li>
<p>API Management is not required to implement the design pattern, but can be added to each geode that fronts the region&#8217;s Azure Function App to provide a more robust API layer, enabling the implementation of additional functionality like rate limiting, for instance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following points when deciding how to implement this pattern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Choose whether to process data locally in each region, or to distribute aggregations in a single geode and replicate the result across the globe. The Azure Cosmos DB change feed processor offers this granular control using its lease container concept, and the leasecollectionprefix in the corresponding Azure Functions binding. Each approach has distinct advantages and drawbacks.</p>
</li>
<li>
<p>Geodes can work in tandem, using the Azure Cosmos DB change feed and a real-time communication platform like SignalR. Geodes can communicate with remote users via other geodes in a mesh pattern, without knowing or caring where the remote user is located.</p>
</li>
<li>
<p>This design pattern implicitly decouples everything, resulting in an ultra-highly distributed and decoupled architecture. Consider how to track different components of the same request as they might execute asynchronously on different instances. A proper monitoring strategy is crucial. Both Azure Front Door and Cosmos DB can be easily integrated with Log Analytics and Azure Functions should be deployed alongside Application Insights to provide a robust monitoring system at each component in the architecture.</p>
</li>
<li>
<p>Distributed deployments have a greater number of secrets and ingress points that require property security measures. Key Vault provides a secure layer for secret management and each layer within the API architecture should be properly secured so that the only ingress point for the API is the front-end service like Azure Front Door. The Cosmos DB should restrict traffic to the Azure Function Apps, and the Function apps to Azure Front Door using Azure Active Directory or practices like IP restriction.</p>
</li>
<li>
<p>Performance is drastically affected by the number of geodes that are deployed and the specific App Service Plans applied to the API technology in each geode. Deployment of additional geodes or movement towards premium tiers come with increased costs for the additional memory and compute, but do not do so on a per transaction basis. Consider load testing the API architecture once deployed and contrast increasing the numbers of geodes with increasing the pricing tier so that the most cost-efficient model is used for your needs.</p>
</li>
<li>
<p>Determine the availability requirements for your data. Cosmos DB has optional flags for enabling multi-region write, availability zones, and more. These increase the availability for the Cosmos DB instance and creates a more resilient data layer, but come with additional costs.</p>
</li>
<li>
<p>Azure offers a variety of load balancers that provide different functionalities for distribution of traffic. Use the <a href="https://docs.microsoft.com/en-us/azure/architecture/guide/technology-choices/load-balancing-overview#decision-tree-for-load-balancing-in-azure">decision tree</a> to help select the right option for your API&#8217;s front end.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_when_to_use_this_pattern">When to use this pattern</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use this pattern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To implement a high-scale platform that has users distributed over a wide area.</p>
</li>
<li>
<p>For any service that requires extreme availability and resilience characteristics, because services based on the geode pattern can survive the loss of multiple service regions at the same time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This pattern might not be suitable for</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Architectures that have constraints so that all geodes can&#8217;t be equal for data storage. For example, there may be data residency requirements, an application that needs to maintain temporary state for a particular session, or a heavy weighting of requests towards a single region. In this case, consider using <a href="deployment-stamp.html">deployment stamps</a> in combination with a global routing plane that is aware of where a user&#8217;s data sits, such as the traffic routing component described within the <a href="deployment-stamp.html">deployment stamps pattern</a>.</p>
</li>
<li>
<p>Situations where there&#8217;s no geographical distribution required. Instead, consider availability zones and paired regions for clustering.</p>
</li>
<li>
<p>Situations where a legacy platform needs to be retrofitted. This pattern works for cloud-native development only, and can be difficult to retrofit.</p>
</li>
<li>
<p>Simple architectures and requirements, where geo-redundancy and geo-distribution aren&#8217;t required or advantageous.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples">Examples</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Windows Active Directory implements an early variant of this pattern. Multi-primary replication means all updates and requests can in theory be served from all serviceable nodes, but Flexible Single Master Operation (FSMO) roles mean that all geodes aren&#8217;t equal.</p>
</li>
<li>
<p>The <a href="https://github.com/mspnp/geode-pattern-accelerator">geode pattern accelerator</a> on GitHub showcases this design pattern in practice and is designed to help developers implement it with real-world APIs.</p>
</li>
<li>
<p>The <a href="https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/globally-distributed-mission-critical-applications-using-cosmos-db">globally distributed applications using Cosmos DB</a> article examines a geographical based deployment that utilizes Traffic Manager for load balancing and Azure App Service to host the API code.</p>
</li>
<li>
<p>A <a href="https://github.com/xstof/qnademo">QnA sample application</a> on GitHub showcases this design pattern in practice.</p>
</li>
<li>
<p>Geode <a href="https://github.com/MartinPankraz/AzCosmosDB-OData-Shim">Cache over SAP OData APIs</a>: A sample OData API Geode set backed by Cosmos as a globally accelerated data cache for SAP Retail applications.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-06-22 13:10:08 UTC
</div>
</div>
</body>
</html>