<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>Claim-Check pattern</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/darshandsoni/asciidoctor-skins/css/material-teal.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./rouge-github.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Claim-Check pattern</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_context_and_problem">Context and problem</a></li>
<li><a href="#_solution">Solution</a></li>
<li><a href="#_issues_and_considerations">Issues and considerations</a></li>
<li><a href="#_when_to_use_this_pattern">When to use this pattern</a></li>
<li><a href="#_examples">Examples</a>
<ul class="sectlevel2">
<li><a href="#_automatic_claim_check_generation_with_blob_storage_and_event_grid">Automatic claim-check generation with Blob Storage and Event Grid</a></li>
<li><a href="#_event_grid_with_event_hubs">Event Grid with Event Hubs</a></li>
<li><a href="#_claim_check_generation_with_service_bus">Claim check generation with Service Bus</a></li>
<li><a href="#_manual_claim_check_generation_with_kafka">Manual claim-check generation with Kafka</a></li>
</ul>
</li>
<li><a href="#_related_guidance">Related guidance</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="title">References</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/StoreInLibrary.html">Claim Check</a></p>
</li>
<li>
<p><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/claim-check">Claim-Check pattern</a></p>
</li>
<li>
<p><a href="https://www.serverless360.com/blog/deal-with-large-service-bus-messages-using-claim-check-pattern">Dealing with large Service Bus messages using claim check pattern</a></p>
</li>
<li>
<p><em>Enterprise Integration Patterns</em>, by Gregor Hohpe and Bobby Woolf</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Split a large message into a claim check and a payload. Send the claim check to the messaging platform and store the payload to an external service. This pattern allows large messages to be processed, while protecting the message bus and the client from being overwhelmed or slowed down. This pattern also helps to reduce costs, as storage is usually cheaper than resource units used by the messaging platform.</p>
</div>
<div class="paragraph">
<p>This pattern is also known as <mark>Reference-Based Messaging</mark>, and was originally described in the book <em>Enterprise Integration Patterns</em>, by Gregor Hohpe and Bobby Woolf.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_context_and_problem">Context and problem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A messaging-based architecture at some point must be able to send, receive, and manipulate large messages. Such messages may contain anything, including images (for example, MRI scans), sound files (for example, call-center calls), text documents, or any kind of binary data of arbitrary size.</p>
</div>
<div class="paragraph">
<p>Sending such large messages to the message bus directly is not recommended, because they require more resources and bandwidth to be consumed. Large messages can also slow down the entire solution, because messaging platforms are usually fine-tuned to handle huge quantities of small messages. Also, most messaging platforms have limits on message size, so you may need to work around these limits for large messages.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_solution">Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Store the entire message payload into an external service, such as a database. Get the reference to the stored payload, and send just that reference to the message bus. The reference acts like a claim check used to retrieve a piece of luggage, hence the name of the pattern. Clients interested in processing that specific message can use the obtained reference to retrieve the payload, if needed.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/claim-check.png" alt="claim check">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_issues_and_considerations">Issues and considerations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Consider the following points when deciding how to implement this pattern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consider deleting the message data after consuming it, if you don&#8217;t need to archive the messages. Although blob storage is relatively cheap, it costs some money in the long run, especially if there is a lot of data. Deleting the message can be done synchronously by the application that receives and processes the message, or asynchronously by a separate dedicated process. The asynchronous approach removes old data with no impact on the throughput and message processing performance of the receiving application.</p>
</li>
<li>
<p>Storing and retrieving the message causes some additional overhead and latency. You may want to implement logic in the sending application to use this pattern only when the message size exceeds the data limit of the message bus. The pattern would be skipped for smaller messages. This approach would result in a conditional claim-check pattern.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_when_to_use_this_pattern">When to use this pattern</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This pattern should be used whenever a message cannot fit the supported message limit of the chosen message bus technology. For example, Event Hubs currently has a limit of 256 KB (Basic Tier), while Event Grid supports only 64-KB messages.</p>
</div>
<div class="paragraph">
<p>The pattern can also be used if the payload should be accessed only by services that are authorized to see it. By offloading the payload to an external resource, stricter authentication and authorization rules can be put in place, to ensure that security is enforced when sensitive data is stored in the payload.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples">Examples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>On Azure, this pattern can be implemented in several ways and with different technologies, but there are two main categories. In both cases, the receiver has the responsibility to read the claim check and use it to retrieve the payload.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Automatic claim-check generation.</dt>
<dd>
<p>This approach uses Azure Event Grid to automatically generate the claim check and push it into the message bus.</p>
</dd>
<dt class="hdlist1">Manual claim-check generation.</dt>
<dd>
<p>In this approach, the sender is responsible for managing the payload. The sender stores the payload using the appropriate service, gets or generates the claim check, and sends the claim check to the message bus.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Event Grid is an event routing service and tries to deliver events within a configurable amount of time up to 24 hours. After that, events are either discarded or dead lettered. If you need to archive the event payloads or replay the event stream, you can add an Event Grid subscription to Event Hubs or Queue Storage, where messages can be retained for longer periods and archiving messages is supported. For information about fine tuning Event Grid message delivery and retry, and dead letter configuration, see <a href="https://docs.microsoft.com/en-us/azure/event-grid/manage-event-delivery">Dead letter and retry policies</a>.</p>
</div>
<div class="sect2">
<h3 id="_automatic_claim_check_generation_with_blob_storage_and_event_grid">Automatic claim-check generation with Blob Storage and Event Grid</h3>
<div class="paragraph">
<p>In this approach, the sender drops the message payload into a designated Azure Blob Storage container. Event Grid automatically generates a tag/reference and sends it to a supported message bus, such as Azure Storage Queues. The receiver can poll the queue, get the message, and then use the stored reference data to download the payload directly from Blob Storage.</p>
</div>
<div class="paragraph">
<p>The same Event Grid message can be directly consumed by Azure Functions, without needing to go through a message bus. This approach takes full advantage of the serverless nature of both Event Grid and Functions.</p>
</div>
<div class="paragraph">
<p>You can find example code for this approach <a href="https://github.com/mspnp/cloud-design-patterns/tree/master/claim-check/code-samples/sample-1">here</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_event_grid_with_event_hubs">Event Grid with Event Hubs</h3>
<div class="paragraph">
<p>Similar to the previous example, Event Grid automatically generates a message when a payload is written to an Azure Blob container. But in this example, the message bus is implemented using Event Hubs. A client can register itself to receive the stream of messages as they are written to the event hub. The event hub can also be configured to archive messages, making them available as an Avro file that can be queried using tools like Apache Spark, Apache Drill, or any of the available Avro libraries.</p>
</div>
<div class="paragraph">
<p>You can find example code for this approach <a href="https://github.com/mspnp/cloud-design-patterns/tree/master/claim-check/code-samples/sample-2">here</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_claim_check_generation_with_service_bus">Claim check generation with Service Bus</h3>
<div class="paragraph">
<p>This solution takes advantage of a specific Service Bus plugin, <a href="https://www.nuget.org/packages/ServiceBus.AttachmentPlugin/">ServiceBus.AttachmentPlugin</a>, which makes the claim-check workflow easy to implement. The plugin converts any message body into an attachment that gets stored in Azure Blob Storage when the message is sent.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="csharp"><span class="k">using</span> <span class="nn">ServiceBus.AttachmentPlugin</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// Getting connection information</span>
<span class="kt">var</span> <span class="n">serviceBusConnectionString</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="nf">GetEnvironmentVariable</span><span class="p">(</span><span class="s">"SERVICE_BUS_CONNECTION_STRING"</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">queueName</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="nf">GetEnvironmentVariable</span><span class="p">(</span><span class="s">"QUEUE_NAME"</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">storageConnectionString</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="nf">GetEnvironmentVariable</span><span class="p">(</span><span class="s">"STORAGE_CONNECTION_STRING"</span><span class="p">);</span>

<span class="c1">// Creating config for sending message</span>
<span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AzureStorageAttachmentConfiguration</span><span class="p">(</span><span class="n">storageConnectionString</span><span class="p">);</span>

<span class="c1">// Creating and registering the sender using Service Bus Connection String and Queue Name</span>
<span class="kt">var</span> <span class="n">sender</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MessageSender</span><span class="p">(</span><span class="n">serviceBusConnectionString</span><span class="p">,</span> <span class="n">queueName</span><span class="p">);</span>
<span class="n">sender</span><span class="p">.</span><span class="nf">RegisterAzureStorageAttachmentPlugin</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>

<span class="c1">// Create payload</span>
<span class="kt">var</span> <span class="n">payload</span> <span class="p">=</span> <span class="k">new</span> <span class="p">{</span> <span class="n">data</span> <span class="p">=</span> <span class="s">"random data string for testing"</span> <span class="p">};</span>
<span class="kt">var</span> <span class="n">serialized</span> <span class="p">=</span> <span class="n">JsonConvert</span><span class="p">.</span><span class="nf">SerializeObject</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">payloadAsBytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">serialized</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Message</span><span class="p">(</span><span class="n">payloadAsBytes</span><span class="p">);</span>

<span class="c1">// Send the message</span>
<span class="k">await</span> <span class="n">sender</span><span class="p">.</span><span class="nf">SendAsync</span><span class="p">(</span><span class="n">message</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Service Bus message acts as a notification queue, which a client can subscribe to. When the consumer receives the message, the plugin makes it possible to directly read the message data from Blob Storage. You can then choose how to process the message further. An advantage of this approach is that it abstracts the claim-check workflow from the sender and receiver.</p>
</div>
<div class="paragraph">
<p>You can find example code for this approach <a href="https://github.com/mspnp/cloud-design-patterns/tree/master/claim-check/code-samples/sample-3">here</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_manual_claim_check_generation_with_kafka">Manual claim-check generation with Kafka</h3>
<div class="paragraph">
<p>In this example, a Kafka client writes the payload to Azure Blob Storage. Then it sends a notification message using Kafka-enabled Event Hubs. The consumer receives the message and can access the payload from Blob Storage. This example shows how a different messaging protocol can be used to implement the claim-check pattern in Azure. For example, you might need to support existing Kafka clients.</p>
</div>
<div class="paragraph">
<p>You can find example code for this approach <a href="https://github.com/mspnp/cloud-design-patterns/tree/master/claim-check/code-samples/sample-4">here</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_related_guidance">Related guidance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An alternative pattern for handling large messages is <a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/Sequencer.html">Split</a> and <a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/Aggregator.html">Aggregate</a>.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-06-22 13:10:08 UTC
</div>
</div>
</body>
</html>