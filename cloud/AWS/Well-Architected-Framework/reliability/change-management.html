<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>Change Management</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/darshandsoni/asciidoctor-skins/css/material-teal.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Change Management</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_implement_change">Implement Change</a>
<ul class="sectlevel2">
<li><a href="#_use_runbooks_for_standard_activities_such_as_deployment">Use runbooks for standard activities such as deployment</a></li>
<li><a href="#_integrate_functional_testing_as_part_of_your_deployment">Integrate functional testing as part of your deployment</a></li>
<li><a href="#_integrate_resiliency_testing_as_part_of_your_deployment">Integrate resiliency testing as part of your deployment</a></li>
<li><a href="#_deploy_using_immutable_infrastructure">Deploy using immutable infrastructure</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_implement_change"><a href="https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/implement-change.html">Implement Change</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Controlled changes are necessary to deploy new functionality and to ensure that the workloads and the operating environment are running known, properly patched software. If these changes are uncontrolled, then it makes it difficult to predict the effect of these changes, or to address issues that arise because of them.</p>
</div>
<div class="sect2">
<h3 id="_use_runbooks_for_standard_activities_such_as_deployment">Use runbooks for standard activities such as deployment</h3>
<div class="paragraph">
<p>Runbooks are the predefined steps to achieve specific outcomes. Use runbooks to perform standard activities, whether done manually or automatically. Examples include deploying a workload, patching it, or making DNS modifications.</p>
</div>
<div class="paragraph">
<p>For example, put processes in place to ensure rollback safety during deployments</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ensuring that you can roll back a deployment without any disruption for your customers is critical in making a service reliable.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For runbook procedures, start with a valid effective manual process, implement it in code, and trigger automated execution where appropriate.</p>
</div>
<div class="paragraph">
<p>Even for sophisticated workloads that are highly automated, runbooks are still useful for running game days or meeting rigorous reporting and auditing requirements.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
playbooks are used in response to specific incidents, and runbooks are used to achieve specific outcomes. Often, runbooks are for routine activities, while playbooks are used for responding to non-routine events.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_integrate_functional_testing_as_part_of_your_deployment">Integrate functional testing as part of your deployment</h3>
<div class="paragraph">
<p>Functional tests are run as part of automated deployment. If success criteria are not met, the pipeline is halted or rolled back.</p>
</div>
<div class="paragraph">
<p>These tests are run in a pre-production environment, which is staged prior to production in the pipeline. Ideally, this is done as part of a deployment pipeline.</p>
</div>
</div>
<div class="sect2">
<h3 id="_integrate_resiliency_testing_as_part_of_your_deployment">Integrate resiliency testing as part of your deployment</h3>
<div class="paragraph">
<p><strong>Resiliency tests (as part of chaos engineering)</strong> are run as part of the automated deployment pipeline in a pre-production environment.</p>
</div>
<div class="paragraph">
<p>These tests are staged and run in the pipeline prior to production. They should also be run in production, but as part of <a href="https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/test-reliability.html#GameDays">Game Days</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_deploy_using_immutable_infrastructure">Deploy using immutable infrastructure</h3>
<div class="paragraph">
<p>This is a model that mandates that no updates, security patches, or configuration changes happen in-place on production systems. When a change is needed, the architecture is built onto new infrastructure and deployed into production.</p>
</div>
<div class="paragraph">
<p>The most common implementation of the immutable infrastructure paradigm is the <strong><em>immutable server</em></strong>. This means that if a server needs an update or a fix, new servers are deployed instead of updating the ones already in use. So, instead of logging into the server via SSH and updating the software version, every change in the application starts with a software push to the code repository, for example, git push. Since changes are not allowed in immutable infrastructure, you can be sure about the state of the deployed system. Immutable infrastructures are inherently more consistent, reliable, and predictable, and they simplify many aspects of software development and operations.</p>
</div>
<div class="paragraph">
<p>Use a canary or blue/green deployment when deploying applications in immutable infrastructures.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://martinfowler.com/bliki/CanaryRelease.html">Canary deployment</a></dt>
<dd>
<p>is the practice of directing a small number of your customers to the new version, usually running on a single service instance (the canary). You then deeply scrutinize any behavior changes or errors that are generated. You can remove traffic from the canary if you encounter critical problems and send the users back to the previous version. If the deployment is successful, you can continue to deploy at your desired velocity, while monitoring the changes for errors, until you are fully deployed. AWS CodeDeploy can be configured with a deployment configuration that will enable a canary deployment.</p>
</dd>
<dt class="hdlist1"><a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">Blue/green deployment</a></dt>
<dd>
<p>is similar to the canary deployment except that a full fleet of the application is deployed in parallel. You alternate your deployments across the two stacks (blue and green). Once again, you can send traffic to the new version, and fall back to the old version if you see problems with the deployment. Commonly all traffic is switched at once, however you can also use fractions of your traffic to each version to dial up the adoption of the new version using the weighted DNS routing capabilities of Amazon Route 53. AWS CodeDeploy and AWS Elastic Beanstalk can be configured with a deployment configuration that will enable a blue/green deployment.</p>
</dd>
</dl>
</div>
<div id="img-blue-green-deployment" class="imageblock">
<div class="content">
<img src="./images/blue-green-deployment.png" alt="blue green deployment">
</div>
<div class="title">Figure 1. Blue/green deployment with AWS Elastic Beanstalk and Amazon Route 53</div>
</div>
<div class="paragraph">
<p>Benefits of immutable infrastructure:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Reduction in configuration drifts
</td>
<td class="hdlist2">
<p>By frequently replacing servers from a base, known and version-controlled configuration, the infrastructure is <strong>reset</strong> to a known state, avoiding configuration drifts.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Simplified deployments
</td>
<td class="hdlist2">
<p>Deployments are simplified because they don’t need to support upgrades. Upgrades are just new deployments.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Reliable atomic deployments
</td>
<td class="hdlist2">
<p>Deployments either complete successfully, or nothing changes. It gives more trust in the deployment process.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Safer deployments with fast rollback and recovery processes
</td>
<td class="hdlist2">
<p>Deployments are safer because the previous working version is not changed. You can roll back to it if errors are detected.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Consistent testing and debugging environments
</td>
<td class="hdlist2">
<p>Since all servers use the same image, there are no differences between environments. One build is deployed to multiple environments. It also prevents inconsistent environments and simplifies testing and debugging.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Increased scalability
</td>
<td class="hdlist2">
<p>Since servers use a base image, are consistent, and repeatable, automatic scaling is trivial.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Simplified toolchain
</td>
<td class="hdlist2">
<p>The toolchain is simplified since you can get rid of configuration management tools managing production software upgrades. No extra tools or agents are installed on servers. Changes are made to the base image, tested, and rolled-out.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Increased security
</td>
<td class="hdlist2">
<p>By denying all changes to servers, you can disable SSH on instances and remove keys. This reduces the attack vector, improving your organization’s security posture.</p>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_deploy_changes_with_automation">Deploy changes with automation</h4>
<div class="paragraph">
<p>Deployments and patching are automated to eliminate negative impact.</p>
</div>
<div class="paragraph">
<p>Making changes to production systems is one of the largest risk areas for many organizations. We consider deployments a first-class problem to be solved alongside the business problems that the software addresses. Today, this means the use of automation wherever practical in operations, including testing and deploying changes, adding or removing capacity, and migrating data. AWS CodePipeline lets you manage the steps required to release your workload. This includes a deployment state using AWS CodeDeploy to automate deployment of application code to Amazon EC2 instances, on-premises instances, serverless Lambda functions, or Amazon ECS services.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Recommendation</div>
<div class="paragraph">
<p>Although conventional wisdom suggests that you keep humans in the loop for the most difficult operational procedures, we suggest that you automate the most difficult procedures for that very reason.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-06-22 13:10:08 UTC
</div>
</div>
</body>
</html>